# Week 11: Dynamic Programming (2D) 📊

## 🎯 Learning Objectives

By the end of this week, you will be able to:
- Solve 2D DP problems efficiently
- Apply grid-based DP patterns
- Handle string DP problems
- Optimize 2D DP space complexity
- Recognize complex state transitions

## 📚 Core Concepts

### 1. 2D DP Patterns
- **Grid problems**: Path counting, optimization
- **String problems**: Edit distance, longest common subsequence
- **Matrix problems**: Chain multiplication, optimization
- **Time complexity**: O(m×n) for m×n grid

### 2. State Transitions
- **Grid movement**: Right, down, diagonal
- **String matching**: Character-by-character comparison
- **Decision making**: Choose optimal path
- **Time complexity**: O(m×n) for most problems

### 3. Space Optimization
- **Rolling arrays**: Reduce space to O(min(m,n))
- **State compression**: Bit manipulation for states
- **In-place updates**: Modify existing array
- **Space complexity**: O(m×n) to O(1)

## 🛠️ Java Implementation

*Implementation details will be added when you reach this topic*

## 🎯 Practice Problems

### Problem 1: Unique Paths (Medium)
**LeetCode #62** - Count unique paths in grid

### Problem 2: Edit Distance (Hard)
**LeetCode #72** - Minimum operations to transform strings

### Problem 3: Longest Common Subsequence (Medium)
**LeetCode #1143** - Find longest common subsequence

## 📋 Self-Review Checklist

*Same checklist structure as Week 1*

## 🚀 Next Steps

*Same progression as Week 1*
