# Week 6: Trees & Binary Search Trees 🌳

## 🎯 Learning Objectives

By the end of this week, you will be able to:
- Traverse trees using DFS techniques
- Implement BST operations efficiently
- Construct trees from various inputs
- Validate BST properties
- Apply tree-based algorithms

## 📚 Core Concepts

### 1. Tree Traversal
- **DFS**: Preorder, inorder, postorder
- **BFS**: Level-order traversal
- **Recursive vs iterative**: Space-time tradeoffs
- **Time complexity**: O(n) for all traversals

### 2. Binary Search Trees
- **Properties**: Left < Root < Right
- **Operations**: Search, insert, delete
- **Balanced vs unbalanced**: Performance implications
- **Time complexity**: O(log n) average, O(n) worst

### 3. Tree Construction
- **From arrays**: Level-order, preorder/inorder
- **From strings**: Serialization/deserialization
- **Balanced construction**: AVL, Red-Black concepts
- **Time complexity**: O(n) for construction

## 🛠️ Java Implementation

*Implementation details will be added when you reach this topic*

## 🎯 Practice Problems

### Problem 1: Maximum Depth of Binary Tree (Easy)
**LeetCode #104** - Find maximum depth of tree

### Problem 2: Validate Binary Search Tree (Medium)
**LeetCode #98** - Check if tree is valid BST

### Problem 3: Construct Binary Tree from Preorder and Inorder (Medium)
**LeetCode #105** - Build tree from traversal arrays

## 📋 Self-Review Checklist

*Same checklist structure as Week 1*

## 🚀 Next Steps

*Same progression as Week 1*
