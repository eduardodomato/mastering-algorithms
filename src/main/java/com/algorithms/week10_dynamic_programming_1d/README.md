# Week 10: Dynamic Programming (1D) 🎯

## 🎯 Learning Objectives

By the end of this week, you will be able to:
- Identify DP problem characteristics
- Apply 1D DP patterns effectively
- Choose between memoization and tabulation
- Optimize space complexity in DP solutions
- Recognize overlapping subproblems

## 📚 Core Concepts

### 1. DP Fundamentals
- **Optimal substructure**: Optimal solution contains optimal subproblems
- **Overlapping subproblems**: Same subproblems solved multiple times
- **State definition**: What information to track
- **Time complexity**: Often O(n) to O(n²)

### 2. 1D DP Patterns
- **Fibonacci sequence**: Classic DP example
- **House robber**: Optimization problems
- **Climbing stairs**: Counting problems
- **Time complexity**: O(n) with O(1) space optimization

### 3. Implementation Approaches
- **Top-down**: Recursion with memoization
- **Bottom-up**: Iterative tabulation
- **Space optimization**: Rolling array technique
- **Time complexity**: Same, space complexity varies

## 🛠️ Java Implementation

*Implementation details will be added when you reach this topic*

## 🎯 Practice Problems

### Problem 1: Climbing Stairs (Easy)
**LeetCode #70** - Count ways to climb stairs

### Problem 2: House Robber (Medium)
**LeetCode #198** - Maximum money without adjacent houses

### Problem 3: Longest Increasing Subsequence (Medium)
**LeetCode #300** - Find longest increasing subsequence

## 📋 Self-Review Checklist

*Same checklist structure as Week 1*

## 🚀 Next Steps

*Same progression as Week 1*
