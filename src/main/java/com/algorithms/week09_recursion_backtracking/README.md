# Week 9: Recursion & Backtracking 🔄

## 🎯 Learning Objectives

By the end of this week, you will be able to:
- Think recursively about problem decomposition
- Implement backtracking algorithms
- Explore state spaces systematically
- Apply pruning techniques for optimization
- Handle recursive base cases properly

## 📚 Core Concepts

### 1. Recursive Thinking
- **Base case**: Termination condition
- **Recursive case**: Problem decomposition
- **Call stack**: Understanding recursion depth
- **Time complexity**: Often exponential without optimization

### 2. Backtracking Patterns
- **State space exploration**: Try all possibilities
- **Constraint satisfaction**: Prune invalid paths
- **Path reconstruction**: Build solutions incrementally
- **Time complexity**: O(b^d) where b=branching, d=depth

### 3. Optimization Techniques
- **Memoization**: Cache computed results
- **Pruning**: Early termination of invalid paths
- **State representation**: Efficient state encoding
- **Time complexity**: Reduces exponential to polynomial

## 🛠️ Java Implementation

*Implementation details will be added when you reach this topic*

## 🎯 Practice Problems

### Problem 1: Generate Parentheses (Medium)
**LeetCode #22** - Generate valid parentheses combinations

### Problem 2: N-Queens (Hard)
**LeetCode #51** - Place N queens on chessboard

### Problem 3: Word Search (Medium)
**LeetCode #79** - Find word in 2D grid

## 📋 Self-Review Checklist

*Same checklist structure as Week 1*

## 🚀 Next Steps

*Same progression as Week 1*
